@startuml Transponder
!define DARKBLUE
!include try.puml
skinparam classBorderThickness 4
skinparam classBorderColor #006700ff
skinparam ArrowColor Black

title "Diagrama de Clases - Transponder"

<style>
  root {
    Margin 50
  }
</style>

interface IDecoderT<PacketT>{
    +~IDecoderT()
    +feed(data:const uint8_t*,len:size_t): void
    +onPacket(std::function<void(const PacketT&)> handler): void
    +reset(): void
}

interface IEncoderT<PacketT>{
    +~IEncoderT()
    +encode(packet:const PacketT&): std::vector<uint8_t>
}

interface ITransport{
    {field}+onOpen: std::function<void()>
    {field}+onData: std::function<void(const uint8_t*, size_t)>
    {field}+onClose: std::function<void()>

    +~ITransport()
    +open(): void
    +close(): void
    +send(data:const uint8_t*,len:size_t): void
}

class SimpleTCP{
    -clientSocket_: int
    -ip_: const char*
    -port_: uint16_t

    -taskHandle_: TaskHandle_t
    
    ' Métodos
    +SimpleTCP(clientSocket: int)
    +SimpleTCP(ip:const char*,port:uint16_t)
    +~SimpleTCP()

    +open(): void
    +close(): void
    +send(data:const uint8_t*,len:size_t): void
    -eventTaskAdapter(arg:void*): void
}
SimpleTCP <|.d. ITransport

class SimpleUart{
    -port_: uart_port_t
    -txpin_: gpio_num_t
    -rxpin_: gpio_num_t
    -baudrate_: uint32_t
    -queue_: QueueHandle_t
    -eventTaskHandle_: TaskHandle_t
    -rxBuffer_: uint8_t*
    -rxbuffersize_: size_t

    +SimpleUart(port:uart_port_t,txpin:gpio_num_t,rxpin:gpio_num_t,baudrate:uint32_t)
    +~SimpleUart()
    +open(): void
    +close(): void
    +send(data:const uint8_t*,len:size_t): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}
SimpleUart <|.u. ITransport

interface IPacketChannelT<PacketT>{
    ' Atributos
    {field}+onPacket: std::function<void(const PacketT&)>
    {field}+onOpen: std::function<void()>
    {field}+onClose: std::function<void()>

    +transport_:ITransport*
    +encoder_:IEncoderT<PacketT>*
    +decoder_:IDecoderT<PacketT>*


    ' Métodos
    +~IPacketChannelT()
    +open(): void
    +close(): void
    +sendPacket(packet:const PacketT&): void
}



class TcpTransportManagerT<PacketT>{
    {field}+onNewChannel: std::function<void(IPacketChannelT<PacketT>*)>
    -port_: uint16_t
    -listenSocket_: netconn *
    -taskHandle_: TaskHandle_t
    -acceptTaskHandle_: TaskHandle_t
    {field}-encoderFactory_: std::function<IEncoderT<PacketT>*()>
    {field}-decoderFactory_: std::function<IDecoderT<PacketT>*()>
    
    -clients_: std::list<void*> 
    
    +TcpTransportManagerT(port: uint16_t)
    +~TcpTransportManagerT()
    +start(df: std::function<IDecoderT<PacketT>*()>, ef: std::function<IEncoderT<PacketT>*()>): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}
TcpTransportManagerT *-r- "0..*" SimpleTCP : -clients_.transport_
TcpTransportManagerT *-d- "0..*" IPacketChannelT : -clients_.packetChannel_
TcpTransportManagerT *-d- "0..*" IEncoderT : -clients_.encoder_
TcpTransportManagerT *-d- "0..*" IDecoderT : -clients_.decoder_

class UartTransportManagerT<PacketT>{
    {field}+onNewChannel: std::function<void(IPacketChannelT<PacketT>*)>
    -port_: uart_port_t
    -txpin_: gpio_num_t
    -rxpin_: gpio_num_t
    -baudrate_: uint32_t

    -packetChannel_: IPacketChannelT<PacketT>*
    -transport_: SimpleUart*
    -encoder_: IEncoderT<PacketT>*
    -decoder_: IDecoderT<PacketT>*

    +UartTransportManagerT(port:uart_port_t,txpin:gpio_num_t,rxpin:gpio_num_t,baudrate:uint32_t)
    +~UartTransportManagerT()
    +start(df: std::function<IDecoderT<PacketT>*()> ,ef: std::function<IEncoderT<PacketT>*()> ): void
}
UartTransportManagerT *-r- "1" SimpleUart : -transport_
UartTransportManagerT *-u- "1" IPacketChannelT : -packetChannel_
UartTransportManagerT *-u- "1" IEncoderT : -encoder_
UartTransportManagerT *-u- "1" IDecoderT : -decoder_

class ChannelTransactorT<PacketT> {
   -wrappedChannel_: IPacketChannelT<PacketT>*
   -mutex_: MutexHandle_t

   +ChannelTransactorT(channelToWrap: IPacketChannelT<PacketT>*)
   +~ChannelTransactorT()
   +open(): void
   +close(): void
   +sendPacket(packet:const PacketT&): void
}
ChannelTransactorT <|.r. IPacketChannelT: "<<decorador>>"

IPacketChannelT --[hidden]right> IDecoderT
IDecoderT --[hidden]right> IEncoderT
IEncoderT --[hidden]right> ITransport

interface IDataNode{
    -periodMs_: uint32_t
    -isSampler_: bool
    -chanel_: IPacketChannelT<void*>*
    -mgBoxAddr_: uint32_t

    +~IDataNode()
    +sample(): void
    +getPeriodMs(): uint32_t
}

class DataNodesManagerT{
    -dataNodes_: std::vector<IDataNode*>
    -samplingTaskHandle_: TaskHandle_t

    +DataNodesManagerT()
    +~DataNodesManagerT()
    +addDataNode(node:IDataNode*): void
    +start(): void
    +stop(): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}

DataNodesManagerT o-r- "0..*" IDataNode : dataNodes_
IDataNode *-- "1" ChannelTransactorT : chanel_

IDataNode --[hidden]right> TcpTransportManagerT


class AlmacenFlexible {
  - m_storage : map<DataID, shared_ptr<DataSlot>>
  - m_mapMutex : MutexHandle_t

  + AlmacenFlexible()
  + registrarProductor<T>(id: DataID) : std::function<void(T)>
  + registrarConsumidor<T>(id: DataID) : std::function<T(void)>

  - getOrCreateSlot<T>(id: DataID) : std::shared_ptr<DataSlot>
}

class AlmacenFlexible::DataSlot {
  + data : std::any
  + slotMutex : MutexHandle_t
  + typeInfo : std::type_index

  + DataSlot(info: std::type_index, defaultVal: std::any)
}

AlmacenFlexible o-r- "0..*" AlmacenFlexible::DataSlot

AlmacenFlexible::DataSlot ---[hidden]right> UartTransportManagerT



' interface ICommand{
'     +execute(): void
' }

' class CommandManager<PacketT>{
'     -commands_: std::vector<ICommand*>
'     -commandQueue_: QueueHandle_t<PacketT>
'     -queueMutex_: MutexHandle_t
'     -commandTaskHandle_: TaskHandle_t

'     +CommandManager()
'     +~CommandManager()
'     +redgisterCommand(cmd:ICommand*): void
'     +start(): void
'     +stop(): void
'     -commandTask(): void
'     -commandTaskAdapter(arg:void*): void
' }

' CommandManager o-r- "0..*" ICommand : comands_

' interface IControl{
'     'Aqui cada control se suscribe a los inputs y outputs que le interesen de el almacen flexible
'     +suscribeInputsAndOutputs(): void
'     +update(): void
' }

' class StateMachine{
'     'aqui no se como ponerlo bien pero tengo un diagrama de estados que tiene que ir aqui.
'     ' el tema es que dependiendo del estado en el que estemos se pueden usar unos oque otros controles
' }

' class controlManager{
'     -controls_: std::vector<IControl*>
'     +controlTaskHandle_: TaskHandle_t

'     +controlManager(StateMachine* sm)
'     +~controlManager()
'     +registerControl(ctrl:IControl*): void
'     +start(): void
'     +stop(): void
'     -controlTask(): void
'     -controlTaskAdapter(arg:void*): void
' }



@enduml



@startuml StateMachine
!define DARKBLUE
!include try.puml
skinparam stateBorderThickness 4
skinparam stateBorderColor #006700ff
skinparam ArrowColor Black
<style>
  root {
    Margin 50
  }
</style>
title "Máquina de Estados - Quien tiene el control\n Una vez esatamos armados es queda asi"
hide empty description

[*] --> NoClient

note "Inputs:\nTCP Client Conected \nIs RC sample Fresh?\nRC aux 1 \nRC aux 2\nTCP Armed\nTCP control selected" as exp1


NoClient --> PC : TCP = 1

NoClient --> RC_Check : RC = 1

RC_Check --> RC_Check : RC.Aux1 = 1

RC_Check --> RC : RC = 1\nRC.Aux1 = 0\nTCP = 0

RC_Check --> MIXTO : RC = 1\nRC.Aux1 = 0\nTCP = 1

PC -r-> RC_Check : RC = 1
RC -l-> MIXTO : TCP = 1\nRC.Aux1 = 0


PC : Nada del mando
RC : Todo del mando
MIXTO : 

note "En este caso todo IBUS \nes sintetico tanto armar \ncomo refs como modo" as n1
n1 -r-> PC
note "En este caso es todo Mando:\narmado y modo de buelo" as n2
n2 -l-> RC


PC --> PC_ARMADO : ARM = 1

state PC_ARMADO {
    [*] --> Espera
    Espera --> Static_rel_move
    Espera --> Weipoints
}

RC --> RC_ARMADO : RC.Aux1 = 1

state RC_ARMADO {
    [*] --> Angle_ALT_Hold : RC.Aux2 = 1
    [*] --> Angle_pass_through : RC.Aux2 = 2
    [*] --> Horizon_pass_through : RC.Aux2 = 3
    [*] --> Acro_pass_through : RC.Aux2 = 4
    Angle_ALT_Hold -[hidden]d-> Angle_pass_through
    Angle_pass_through -[hidden]d-> Horizon_pass_through
    Horizon_pass_through -[hidden]d-> Acro_pass_through
}

MIXTO --> MIXTO_ARMADO : RC.Aux1 = 1

state MIXTO_ARMADO {
    note "Aqui lo que pasa es que si armas el mando usas controles del mando" as n3
    note "Entonces se puede usar para mover el dron ponerlo \nen una posicion y mandarle una ruta desde pc" as n4
    n3 -[hidden]d-> n4
}


@enduml

@startuml
skinparam backgroundColor #FEFECE
skinparam state {
    BackgroundColor<<Safety>> LightCoral
    BorderColor<<Safety>> DarkRed
    BackgroundColor<<Control>> LightBlue
    BorderColor<<Control>> DarkBlue
    BackgroundColor<<Mode>> PaleGreen
    BorderColor<<Mode>> DarkGreen
}

title Sistema de Control Dual - Arquitectura de Máquina de Estados

[*] --> SAFETY_DISARMED : Inicialización

state "Sistema A" as sysA #LightGray {
    [*] --> A_IDLE
    A_IDLE : Health Score > 70
    A_IDLE : Tx Rate > 10Hz
    A_IDLE : CRC Errors < 5%
    A_IDLE --> A_FAILED : Health < 30
    A_IDLE --> A_REQUESTING : Control Request
    A_REQUESTING : Enviando CONTROL_REQ @ 10Hz
}

state "Sistema B" as sysB #LightGray {
    [*] --> B_IDLE
    B_IDLE : Health Score > 70
    B_IDLE : Tx Rate > 10Hz
    B_IDLE : CRC Errors < 5%
    B_IDLE --> B_FAILED : Health < 30
    B_IDLE --> B_REQUESTING : Control Request
    B_REQUESTING : Enviando CONTROL_REQ @ 10Hz
    B_REQUESTING : Prioridad > A
}

state "SAFETY_DISARMED" as SD <<Safety>> {
    SD : Motores OFF
    SD : Ignorar comandos de vuelo
    SD : Monitorear salud A/B
}

state "SAFETY_ARMING" as SA <<Safety>> {
    SA : Verificando...
    SA : • IMU Calibrado
    SA : • GPS 3D Lock (HDOP < 2.0)
    SA : • Batería > 20%
    SA : • A&B transmitiendo OK
    SA : Timeout = 3s
}

state "SAFETY_ARMED" as SARM <<Safety>> {
    [*] --> CTRL_NONE
    
    state "CTRL_NONE" as CN <<Control>> {
        CN : Sin autoridad
        CN : Motores en IDLE
    }
    
    state "CTRL_TRANSITION" as CT <<Control>> {
        CT : Blind Time = 500ms
        CT : Ignorar paquetes de control
        CT : Mantener última referencia válida
    }
    
    state "CTRL_A" as CA <<Control>> {
        [*] --> MODE_STATIC_HOLD
        MODE_STATIC_HOLD --> MODE_RELATIVE_MOVE : Packet CMD + ref válida
        MODE_STATIC_HOLD --> MODE_GPS_NAV : Packet CMD + waypoint ID
        MODE_RELATIVE_MOVE --> MODE_STATIC_HOLD : Timeout 100ms
        MODE_GPS_NAV --> MODE_STATIC_HOLD : Timeout 100ms
    }
    
    state "CTRL_B" as CB <<Control>> {
        [*] --> MODE_STATIC_HOLD
        MODE_STATIC_HOLD --> MODE_ANGLE_ALTHOLD : Packet CMD + ángulo
        MODE_STATIC_HOLD --> MODE_ANGLE_NORMAL : Packet CMD + ángulo
        MODE_ANGLE_ALTHOLD --> MODE_STATIC_HOLD : Timeout 100ms
        MODE_ANGLE_NORMAL --> MODE_STATIC_HOLD : Timeout 100ms
    }
    
    CN --> CT : A o B solicita
    CT --> CA : Si A gana + salud OK
    CT --> CB : Si B gana + salud OK (prioridad)
    CA --> CT : B solicita (mejor prioridad)
    CB --> CT : A solicita y B falla
    CA --> CN : Health A < 50
    CB --> CN : Health B < 50
}

state "SAFETY_EMERGENCY" as SE <<Safety>> {
    SE : DESARME FORZOSO
    SE : Motores OFF inmediato
    SE : Log de causa
}

SD --> SA : ARM_COMMAND\n(stick down-right 3s) + checks OK
SA --> SD : Timeout/Abort\n(cualquier stick)
SA --> SARM : Checks confirmados\n(100% OK)
SARM --> SD : DISARM_COMMAND\n(emergency switch)
SARM --> SE : • Health < 30\n• Pérdida link > 5s\n• Piloto EMERGENCY\n• Watchdog timeout
SE --> SD : Reset manual +自检

note right of SARM : "Matriz de Transiciones:\nStatic Hold ↔ Cualquier modo (mismo control)\nCambio A→B o B→A: OBLIGATORIO pasar por Static Hold 2s"

note right of sysA : "Validación de Paquetes:\n• Timestamp < 100ms\n• CRC16 OK\n• ID consecutivo\n• Rate > 10Hz"

note left of sysB : "Watchdog:\n• Actualizar last_packet_time\n• Health Score = f(rate, crc, timeout)\n• < 60 → Forzar Static Hold\n• < 30 → EMERGENCY"

@enduml