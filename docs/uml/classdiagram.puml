@startuml Transponder
!define DARKBLUE
!include try.puml
skinparam classBorderThickness 4
skinparam classBorderColor #006700ff
skinparam ArrowColor Black

title "Diagrama de Clases - Transponder"

<style>
  root {
    Margin 50
  }
</style>

interface IDecoderT<PacketT>{
    +~IDecoderT()
    +feed(data:const uint8_t*,len:size_t): void
    +onPacket(std::function<void(const PacketT&)> handler): void
    +reset(): void
}

interface IEncoderT<PacketT>{
    +~IEncoderT()
    +encode(packet:const PacketT&): std::vector<uint8_t>
}

interface ITransport{
    {field}+onOpen: std::function<void()>
    {field}+onData: std::function<void(const uint8_t*, size_t)>
    {field}+onClose: std::function<void()>

    +~ITransport()
    +open(): void
    +close(): void
    +send(data:const uint8_t*,len:size_t): void
}

class SimpleTCP{
    -clientSocket_: netconn *
    -taskHandle_: TaskHandle_t
    
    ' Métodos
    +SimpleTCP(clientSocket: netconn *)
    +~SimpleTCP()
    +open(): void
    +close(): void
    +send(data:const uint8_t*,len:size_t): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}
SimpleTCP <|.d. ITransport

class SimpleUart{
    -port_: uart_port_t
    -txpin_: gpio_num_t
    -rxpin_: gpio_num_t
    -baudrate_: uint32_t
    -queue_: QueueHandle_t
    -eventTaskHandle_: TaskHandle_t
    -rxBuffer_: uint8_t*
    -rxbuffersize_: size_t

    +SimpleUart(port:uart_port_t,txpin:gpio_num_t,rxpin:gpio_num_t,baudrate:uint32_t)
    +~SimpleUart()
    +open(): void
    +close(): void
    +send(data:const uint8_t*,len:size_t): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}
SimpleUart <|.u. ITransport

interface IPacketChannelT<PacketT>{
    ' Atributos
    {field}+onPacket: std::function<void(const PacketT&)>
    {field}+onOpen: std::function<void()>
    {field}+onClose: std::function<void()>

    ' Métodos
    +~IPacketChannelT()
    +open(): void
    +close(): void
    +sendPacket(packet:const PacketT&): void
}

class TcpTransportManagerT<PacketT>{
    {field}+onNewChannel: std::function<void(IPacketChannelT<PacketT>*)>
    -port_: uint16_t
    -listenSocket_: netconn *
    -taskHandle_: TaskHandle_t
    -acceptTaskHandle_: TaskHandle_t
    {field}-encoderFactory_: std::function<IEncoderT<PacketT>*()>
    {field}-decoderFactory_: std::function<IDecoderT<PacketT>*()>
    
    -clients_: std::list<void*> 
    
    +TcpTransportManagerT(port: uint16_t)
    +~TcpTransportManagerT()
    +start(df: std::function<IDecoderT<PacketT>*()>, ef: std::function<IEncoderT<PacketT>*()>): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}
TcpTransportManagerT *-r- "0..*" SimpleTCP : -clients_.transport_
TcpTransportManagerT *-d- "0..*" IPacketChannelT : -clients_.packetChannel_
TcpTransportManagerT *-d- "0..*" IEncoderT : -clients_.encoder_
TcpTransportManagerT *-d- "0..*" IDecoderT : -clients_.decoder_

class UartTransportManagerT<PacketT>{
    {field}+onNewChannel: std::function<void(IPacketChannelT<PacketT>*)>
    -port_: uart_port_t
    -txpin_: gpio_num_t
    -rxpin_: gpio_num_t
    -baudrate_: uint32_t

    -packetChannel_: IPacketChannelT<PacketT>*
    -transport_: SimpleUart*
    -encoder_: IEncoderT<PacketT>*
    -decoder_: IDecoderT<PacketT>*

    +UartTransportManagerT(port:uart_port_t,txpin:gpio_num_t,rxpin:gpio_num_t,baudrate:uint32_t)
    +~UartTransportManagerT()
    +start(df: std::function<IDecoderT<PacketT>*()> ,ef: std::function<IEncoderT<PacketT>*()> ): void
}
UartTransportManagerT *-r- "1" SimpleUart : -transport_
UartTransportManagerT *-u- "1" IPacketChannelT : -packetChannel_
UartTransportManagerT *-u- "1" IEncoderT : -encoder_
UartTransportManagerT *-u- "1" IDecoderT : -decoder_

class ChannelTransactorT<PacketT> {
   -wrappedChannel_: IPacketChannelT<PacketT>*
   -mutex_: MutexHandle_t

   +ChannelTransactorT(channelToWrap: IPacketChannelT<PacketT>*)
   +~ChannelTransactorT()
   +open(): void
   +close(): void
   +sendPacket(packet:const PacketT&): void
}
ChannelTransactorT <|.r. IPacketChannelT: "<<decorador>>"

IPacketChannelT --[hidden]right> IDecoderT
IDecoderT --[hidden]right> IEncoderT
IEncoderT --[hidden]right> ITransport

interface IDataNode{
    -periodMs_: uint32_t
    -isSampler_: bool
    -chanel_: IPacketChannelT<void*>*
    -mgBoxAddr_: uint32_t

    +~IDataNode()
    +sample(): void
    +getPeriodMs(): uint32_t
}

class DataNodesManagerT{
    -dataNodes_: std::vector<IDataNode*>
    -samplingTaskHandle_: TaskHandle_t

    +DataNodesManagerT()
    +~DataNodesManagerT()
    +addDataNode(node:IDataNode*): void
    +start(): void
    +stop(): void
    -eventTask(): void
    -eventTaskAdapter(arg:void*): void
}

DataNodesManagerT o-r- "0..*" IDataNode : dataNodes_
IDataNode *-- "1" ChannelTransactorT : chanel_

IDataNode --[hidden]right> TcpTransportManagerT


class AlmacenFlexible {
  - m_storage : map<DataID, shared_ptr<DataSlot>>
  - m_mapMutex : std::mutex

  + AlmacenFlexible()
  + registrarProductor<T>(id: DataID) : std::function<void(T)>
  + registrarConsumidor<T>(id: DataID) : std::function<T(void)>

  - getOrCreateSlot<T>(id: DataID) : std::shared_ptr<DataSlot>
}

class AlmacenFlexible::DataSlot {
  + data : std::any
  + slotMutex : std::mutex
  + typeInfo : std::type_index

  + DataSlot(info: std::type_index, defaultVal: std::any)
}

AlmacenFlexible o-r- "0..*" AlmacenFlexible::DataSlot

AlmacenFlexible::DataSlot ---[hidden]right> UartTransportManagerT

interface ICommand{
    +execute(): void
}

class CommandManager<PacketT>{
    -commands_: std::vector<ICommand*>
    -commandQueue_: QueueHandle_t<PacketT>
    -queueMutex_: MutexHandle_t
    -commandTaskHandle_: TaskHandle_t

    +CommandManager()
    +~CommandManager()
    +redgisterCommand(cmd:ICommand*): void
    +start(): void
    +stop(): void
    -commandTask(): void
    -commandTaskAdapter(arg:void*): void
}

CommandManager o-r- "0..*" ICommand : comands_

interface IControl{
    'Aqui cada control se suscribe a los inputs y outputs que le interesen de el almacen flexible
    +suscribeInputsAndOutputs(): void
    +update(): void
}

class StateMachine{
    'aqui no se como ponerlo bien pero tengo un diagrama de estados que tiene que ir aqui.
    ' el tema es que dependiendo del estado en el que estemos se pueden usar unos oque otros controles
}

class controlManager{
    -controls_: std::vector<IControl*>
    +controlTaskHandle_: TaskHandle_t

    +controlManager(StateMachine* sm)
    +~controlManager()
    +registerControl(ctrl:IControl*): void
    +start(): void
    +stop(): void
    -controlTask(): void
    -controlTaskAdapter(arg:void*): void
}



@enduml



@startuml StateMachine
!define DARKBLUE
!include try.puml
skinparam stateBorderThickness 4
skinparam stateBorderColor #006700ff
skinparam ArrowColor Black
<style>
  root {
    Margin 50
  }
</style>
title "Máquina de Estados - Quien tiene el control\n Una vez esatamos armados es queda asi"
hide empty description

[*] --> NoClient

note "Inputs:\nTCP Client Conected \nIs RC sample Fresh?\nRC aux 1 \nRC aux 2\nTCP Armed\nTCP control selected" as exp1


NoClient --> PC : TCP = 1

NoClient --> RC_Check : RC = 1

RC_Check --> RC_Check : RC.Aux1 = 1

RC_Check --> RC : RC = 1\nRC.Aux1 = 0\nTCP = 0

RC_Check --> MIXTO : RC = 1\nRC.Aux1 = 0\nTCP = 1

PC -r-> RC_Check : RC = 1
RC -l-> MIXTO : TCP = 1\nRC.Aux1 = 0


PC : Nada del mando
RC : Todo del mando
MIXTO : 

note "En este caso todo IBUS \nes sintetico tanto armar \ncomo refs como modo" as n1
n1 -r-> PC
note "En este caso es todo Mando:\narmado y modo de buelo" as n2
n2 -l-> RC


PC --> PC_ARMADO : ARM = 1

state PC_ARMADO {
    [*] --> Espera
    Espera --> Static_rel_move
    Espera --> Weipoints
}

RC --> RC_ARMADO : RC.Aux1 = 1

state RC_ARMADO {
    [*] --> Angle_ALT_Hold : RC.Aux2 = 1
    [*] --> Angle_pass_through : RC.Aux2 = 2
    [*] --> Horizon_pass_through : RC.Aux2 = 3
    [*] --> Acro_pass_through : RC.Aux2 = 4
    Angle_ALT_Hold -[hidden]d-> Angle_pass_through
    Angle_pass_through -[hidden]d-> Horizon_pass_through
    Horizon_pass_through -[hidden]d-> Acro_pass_through
}

MIXTO --> MIXTO_ARMADO : RC.Aux1 = 1

state MIXTO_ARMADO {
    note "Aqui lo que pasa es que si armas el mando usas controles del mando" as n3
    note "Entonces se puede usar para mover el dron ponerlo \nen una posicion y mandarle una ruta desde pc" as n4
    n3 -[hidden]d-> n4
}


@enduml